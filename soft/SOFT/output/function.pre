
# 1 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\function.c"

# 26 "C:\Program Files (x86)\SCMCU_IDE_V2.00.07\data\include\htc.h"
extern const char __xc8_OPTIM_SPEED;

extern double __fpnormalize(double);


# 13 "C:\Program Files (x86)\SCMCU_IDE_V2.00.07\data\include\xc8debug.h"
#pragma intrinsic(__builtin_software_breakpoint)
extern void __builtin_software_breakpoint(void);

# 8 "C:\Program Files (x86)\SCMCU_IDE_V2.00.07\data\include\SC8F3752.h"
volatile unsigned char INDF @ 0x0000;
volatile unsigned char TMR0 @ 0x0001;
volatile unsigned char PCL @ 0x0002;
volatile unsigned char STATUS @ 0x0003;
volatile unsigned char FSR @ 0x0004;
volatile unsigned char PORTA @ 0x0005;
volatile unsigned char PORTB @ 0x0006;
volatile unsigned char WPDA @ 0x0007;
volatile unsigned char WPDB @ 0x0008;
volatile unsigned char PCLATH @ 0x000A;
volatile unsigned char INTCON @ 0x000B;
volatile unsigned char PIR1 @ 0x000C;
volatile unsigned char PIR2 @ 0x000D;
volatile unsigned char TMR1L @ 0x000E;
volatile unsigned char TMR1H @ 0x000F;
volatile unsigned char T1CON @ 0x0010;
volatile unsigned char TMR2 @ 0x0011;
volatile unsigned char T2CON @ 0x0012;
volatile unsigned char ADRESH @ 0x001E;
volatile unsigned char ADCON0 @ 0x001F;
volatile unsigned char OPTION_REG @ 0x0081;
volatile unsigned char TRISA @ 0x0085;
volatile unsigned char TRISB @ 0x0086;
volatile unsigned char IOCA @ 0x0087;
volatile unsigned char PIE1 @ 0x008C;
volatile unsigned char PIE2 @ 0x008D;
volatile unsigned char OSCCON @ 0x008F;
volatile unsigned char OSCTUNE @ 0x0090;
volatile unsigned char PR2 @ 0x0092;
volatile unsigned char PWM01DT @ 0x0093;
volatile unsigned char PWM23DT @ 0x0094;
volatile unsigned char WPUB @ 0x0095;
volatile unsigned char IOCB @ 0x0096;
volatile unsigned char LVDCON @ 0x0097;
volatile unsigned char OPA0CON @ 0x009A;
volatile unsigned char OPA0ADJ @ 0x009B;
volatile unsigned char OPA1CON @ 0x009C;
volatile unsigned char OPA1ADJ @ 0x009D;
volatile unsigned char ADRESL @ 0x009E;
volatile unsigned char ADCON1 @ 0x009F;
volatile unsigned char WDTCON @ 0x0105;
volatile unsigned char PWMCON0 @ 0x0107;
volatile unsigned char PWMCON1 @ 0x0108;
volatile unsigned char PWMCON2 @ 0x0109;
volatile unsigned char EEDAT @ 0x010C;
volatile unsigned char EEADR @ 0x010D;
volatile unsigned char EEDATH @ 0x010E;
volatile unsigned char EEADRH @ 0x010F;
volatile unsigned char TABLE_SPH @ 0x0110;
volatile unsigned char TABLE_SPL @ 0x0111;
volatile unsigned char TABLE_DATAH @ 0x0112;
volatile unsigned char PWMD01H @ 0x011C;
volatile unsigned char PWMD23H @ 0x011D;
volatile unsigned char ANSEL @ 0x0188;
volatile unsigned char ANSELH @ 0x0189;
volatile unsigned char EECON1 @ 0x018C;
volatile unsigned char EECON2 @ 0x018D;
volatile unsigned char WPUA @ 0x018E;
volatile unsigned char PWMTL @ 0x018F;
volatile unsigned char PWMTH @ 0x0190;
volatile unsigned char PWMT4L @ 0x0191;
volatile unsigned char PWMD0L @ 0x0193;
volatile unsigned char PWMD1L @ 0x0194;
volatile unsigned char PWMD2L @ 0x0195;
volatile unsigned char PWMD3L @ 0x0196;
volatile unsigned char PWMD4L @ 0x0197;

# 79
volatile bit IRP @ ((unsigned)&STATUS*8)+7;
volatile bit RP1 @ ((unsigned)&STATUS*8)+6;
volatile bit RP0 @ ((unsigned)&STATUS*8)+5;
volatile bit TO @ ((unsigned)&STATUS*8)+4;
volatile bit PD @ ((unsigned)&STATUS*8)+3;
volatile bit Z @ ((unsigned)&STATUS*8)+2;
volatile bit DC @ ((unsigned)&STATUS*8)+1;
volatile bit C @ ((unsigned)&STATUS*8)+0;



volatile bit RA7 @ ((unsigned)&PORTA*8)+7;
volatile bit RA6 @ ((unsigned)&PORTA*8)+6;
volatile bit RA5 @ ((unsigned)&PORTA*8)+5;
volatile bit RA4 @ ((unsigned)&PORTA*8)+4;
volatile bit RA3 @ ((unsigned)&PORTA*8)+3;
volatile bit RA2 @ ((unsigned)&PORTA*8)+2;
volatile bit RA1 @ ((unsigned)&PORTA*8)+1;
volatile bit RA0 @ ((unsigned)&PORTA*8)+0;



volatile bit RB5 @ ((unsigned)&PORTB*8)+5;
volatile bit RB4 @ ((unsigned)&PORTB*8)+4;
volatile bit RB3 @ ((unsigned)&PORTB*8)+3;
volatile bit RB2 @ ((unsigned)&PORTB*8)+2;
volatile bit RB1 @ ((unsigned)&PORTB*8)+1;
volatile bit RB0 @ ((unsigned)&PORTB*8)+0;



volatile bit WPDA7 @ ((unsigned)&WPDA*8)+7;
volatile bit WPDA6 @ ((unsigned)&WPDA*8)+6;
volatile bit WPDA5 @ ((unsigned)&WPDA*8)+5;
volatile bit WPDA4 @ ((unsigned)&WPDA*8)+4;
volatile bit WPDA3 @ ((unsigned)&WPDA*8)+3;
volatile bit WPDA2 @ ((unsigned)&WPDA*8)+2;
volatile bit WPDA1 @ ((unsigned)&WPDA*8)+1;
volatile bit WPDA0 @ ((unsigned)&WPDA*8)+0;



volatile bit WPDB5 @ ((unsigned)&WPDB*8)+5;
volatile bit WPDB4 @ ((unsigned)&WPDB*8)+4;
volatile bit WPDB3 @ ((unsigned)&WPDB*8)+3;
volatile bit WPDB2 @ ((unsigned)&WPDB*8)+2;
volatile bit WPDB1 @ ((unsigned)&WPDB*8)+1;
volatile bit WPDB0 @ ((unsigned)&WPDB*8)+0;



volatile bit GIE @ ((unsigned)&INTCON*8)+7;
volatile bit PEIE @ ((unsigned)&INTCON*8)+6;
volatile bit T0IE @ ((unsigned)&INTCON*8)+5;
volatile bit INTE @ ((unsigned)&INTCON*8)+4;
volatile bit RBIE @ ((unsigned)&INTCON*8)+3;
volatile bit T0IF @ ((unsigned)&INTCON*8)+2;
volatile bit INTF @ ((unsigned)&INTCON*8)+1;
volatile bit RBIF @ ((unsigned)&INTCON*8)+0;



volatile bit RAIF @ ((unsigned)&PIR1*8)+7;
volatile bit ADIF @ ((unsigned)&PIR1*8)+6;
volatile bit EEIF @ ((unsigned)&PIR1*8)+3;
volatile bit PWMIF @ ((unsigned)&PIR1*8)+2;
volatile bit TMR2IF @ ((unsigned)&PIR1*8)+1;
volatile bit TMR1IF @ ((unsigned)&PIR1*8)+0;



volatile bit LVDIF @ ((unsigned)&PIR2*8)+0;



volatile bit T1GINV @ ((unsigned)&T1CON*8)+7;
volatile bit TMR1GE @ ((unsigned)&T1CON*8)+6;
volatile bit T1CKPS1 @ ((unsigned)&T1CON*8)+5;
volatile bit T1CKPS0 @ ((unsigned)&T1CON*8)+4;
volatile bit T1SYNC @ ((unsigned)&T1CON*8)+2;
volatile bit TMR1CS @ ((unsigned)&T1CON*8)+1;
volatile bit TMR1ON @ ((unsigned)&T1CON*8)+0;



volatile bit TOUTPS3 @ ((unsigned)&T2CON*8)+6;
volatile bit TOUTPS2 @ ((unsigned)&T2CON*8)+5;
volatile bit TOUTPS1 @ ((unsigned)&T2CON*8)+4;
volatile bit TOUTPS0 @ ((unsigned)&T2CON*8)+3;
volatile bit TMR2ON @ ((unsigned)&T2CON*8)+2;
volatile bit T2CKPS1 @ ((unsigned)&T2CON*8)+1;
volatile bit T2CKPS0 @ ((unsigned)&T2CON*8)+0;



volatile bit ADCS1 @ ((unsigned)&ADCON0*8)+7;
volatile bit ADCS0 @ ((unsigned)&ADCON0*8)+6;
volatile bit CHS3 @ ((unsigned)&ADCON0*8)+5;
volatile bit CHS2 @ ((unsigned)&ADCON0*8)+4;
volatile bit CHS1 @ ((unsigned)&ADCON0*8)+3;
volatile bit CHS0 @ ((unsigned)&ADCON0*8)+2;
volatile bit GODONE @ ((unsigned)&ADCON0*8)+1;
volatile bit ADON @ ((unsigned)&ADCON0*8)+0;



volatile bit INTEDG @ ((unsigned)&OPTION_REG*8)+6;
volatile bit T0CS @ ((unsigned)&OPTION_REG*8)+5;
volatile bit T0SE @ ((unsigned)&OPTION_REG*8)+4;
volatile bit PSA @ ((unsigned)&OPTION_REG*8)+3;
volatile bit PS2 @ ((unsigned)&OPTION_REG*8)+2;
volatile bit PS1 @ ((unsigned)&OPTION_REG*8)+1;
volatile bit PS0 @ ((unsigned)&OPTION_REG*8)+0;



volatile bit TRISA7 @ ((unsigned)&TRISA*8)+7;
volatile bit TRISA6 @ ((unsigned)&TRISA*8)+6;
volatile bit TRISA5 @ ((unsigned)&TRISA*8)+5;
volatile bit TRISA4 @ ((unsigned)&TRISA*8)+4;
volatile bit TRISA3 @ ((unsigned)&TRISA*8)+3;
volatile bit TRISA2 @ ((unsigned)&TRISA*8)+2;
volatile bit TRISA1 @ ((unsigned)&TRISA*8)+1;
volatile bit TRISA0 @ ((unsigned)&TRISA*8)+0;



volatile bit TRISB5 @ ((unsigned)&TRISB*8)+5;
volatile bit TRISB4 @ ((unsigned)&TRISB*8)+4;
volatile bit TRISB3 @ ((unsigned)&TRISB*8)+3;
volatile bit TRISB2 @ ((unsigned)&TRISB*8)+2;
volatile bit TRISB1 @ ((unsigned)&TRISB*8)+1;
volatile bit TRISB0 @ ((unsigned)&TRISB*8)+0;



volatile bit IOCA7 @ ((unsigned)&IOCA*8)+7;
volatile bit IOCA6 @ ((unsigned)&IOCA*8)+6;
volatile bit IOCA5 @ ((unsigned)&IOCA*8)+5;
volatile bit IOCA4 @ ((unsigned)&IOCA*8)+4;
volatile bit IOCA3 @ ((unsigned)&IOCA*8)+3;
volatile bit IOCA2 @ ((unsigned)&IOCA*8)+2;
volatile bit IOCA1 @ ((unsigned)&IOCA*8)+1;
volatile bit IOCA0 @ ((unsigned)&IOCA*8)+0;



volatile bit RAIE @ ((unsigned)&PIE1*8)+7;
volatile bit ADIE @ ((unsigned)&PIE1*8)+6;
volatile bit EEIE @ ((unsigned)&PIE1*8)+3;
volatile bit PWMIE @ ((unsigned)&PIE1*8)+2;
volatile bit TMR2IE @ ((unsigned)&PIE1*8)+1;
volatile bit TMR1IE @ ((unsigned)&PIE1*8)+0;



volatile bit LVDIE @ ((unsigned)&PIE2*8)+0;



volatile bit IRCF2 @ ((unsigned)&OSCCON*8)+6;
volatile bit IRCF1 @ ((unsigned)&OSCCON*8)+5;
volatile bit IRCF0 @ ((unsigned)&OSCCON*8)+4;
volatile bit SCS @ ((unsigned)&OSCCON*8)+0;



volatile bit TUN4 @ ((unsigned)&OSCTUNE*8)+4;
volatile bit TUN3 @ ((unsigned)&OSCTUNE*8)+3;
volatile bit TUN2 @ ((unsigned)&OSCTUNE*8)+2;
volatile bit TUN1 @ ((unsigned)&OSCTUNE*8)+1;
volatile bit TUN0 @ ((unsigned)&OSCTUNE*8)+0;



volatile bit WPUB5 @ ((unsigned)&WPUB*8)+5;
volatile bit WPUB4 @ ((unsigned)&WPUB*8)+4;
volatile bit WPUB3 @ ((unsigned)&WPUB*8)+3;
volatile bit WPUB2 @ ((unsigned)&WPUB*8)+2;
volatile bit WPUB1 @ ((unsigned)&WPUB*8)+1;
volatile bit WPUB0 @ ((unsigned)&WPUB*8)+0;



volatile bit IOCB5 @ ((unsigned)&IOCB*8)+5;
volatile bit IOCB4 @ ((unsigned)&IOCB*8)+4;
volatile bit IOCB3 @ ((unsigned)&IOCB*8)+3;
volatile bit IOCB2 @ ((unsigned)&IOCB*8)+2;
volatile bit IOCB1 @ ((unsigned)&IOCB*8)+1;
volatile bit IOCB0 @ ((unsigned)&IOCB*8)+0;



volatile bit LVD_RES @ ((unsigned)&LVDCON*8)+7;
volatile bit LVD_SEL2 @ ((unsigned)&LVDCON*8)+3;
volatile bit LVD_SEL1 @ ((unsigned)&LVDCON*8)+2;
volatile bit LVD_SEL0 @ ((unsigned)&LVDCON*8)+1;
volatile bit LVDEN @ ((unsigned)&LVDCON*8)+0;



volatile bit OPA0EN @ ((unsigned)&OPA0CON*8)+7;
volatile bit OPA0O @ ((unsigned)&OPA0CON*8)+6;
volatile bit OPA0_CMP @ ((unsigned)&OPA0CON*8)+5;
volatile bit OPA0_ADC @ ((unsigned)&OPA0CON*8)+4;
volatile bit OPA0_FW @ ((unsigned)&OPA0CON*8)+3;
volatile bit OPA0_BG @ ((unsigned)&OPA0CON*8)+2;



volatile bit OPA0OUT @ ((unsigned)&OPA0ADJ*8)+7;
volatile bit OPA0COFM @ ((unsigned)&OPA0ADJ*8)+6;
volatile bit OPA0CRS @ ((unsigned)&OPA0ADJ*8)+5;
volatile bit OPA0ADJ4 @ ((unsigned)&OPA0ADJ*8)+4;
volatile bit OPA0ADJ3 @ ((unsigned)&OPA0ADJ*8)+3;
volatile bit OPA0ADJ2 @ ((unsigned)&OPA0ADJ*8)+2;
volatile bit OPA0ADJ1 @ ((unsigned)&OPA0ADJ*8)+1;
volatile bit OPA0ADJ0 @ ((unsigned)&OPA0ADJ*8)+0;



volatile bit OPA1EN @ ((unsigned)&OPA1CON*8)+7;
volatile bit OPA1O @ ((unsigned)&OPA1CON*8)+6;
volatile bit OPA1_CMP @ ((unsigned)&OPA1CON*8)+5;
volatile bit OPA1_ADC @ ((unsigned)&OPA1CON*8)+4;
volatile bit OPA1_FW @ ((unsigned)&OPA1CON*8)+3;
volatile bit OPA1_BG @ ((unsigned)&OPA1CON*8)+2;



volatile bit OPA1OUT @ ((unsigned)&OPA1ADJ*8)+7;
volatile bit OPA1COFM @ ((unsigned)&OPA1ADJ*8)+6;
volatile bit OPA1CRS @ ((unsigned)&OPA1ADJ*8)+5;
volatile bit OPA1ADJ4 @ ((unsigned)&OPA1ADJ*8)+4;
volatile bit OPA1ADJ3 @ ((unsigned)&OPA1ADJ*8)+3;
volatile bit OPA1ADJ2 @ ((unsigned)&OPA1ADJ*8)+2;
volatile bit OPA1ADJ1 @ ((unsigned)&OPA1ADJ*8)+1;
volatile bit OPA1ADJ0 @ ((unsigned)&OPA1ADJ*8)+0;



volatile bit ADFM @ ((unsigned)&ADCON1*8)+7;
volatile bit LDO_EN @ ((unsigned)&ADCON1*8)+2;
volatile bit LDO_SEL @ ((unsigned)&ADCON1*8)+0;



volatile bit SWDTEN @ ((unsigned)&WDTCON*8)+0;



volatile bit CLKDIV2 @ ((unsigned)&PWMCON0*8)+7;
volatile bit CLKDIV1 @ ((unsigned)&PWMCON0*8)+6;
volatile bit CLKDIV0 @ ((unsigned)&PWMCON0*8)+5;
volatile bit PWM4EN @ ((unsigned)&PWMCON0*8)+4;
volatile bit PWM3EN @ ((unsigned)&PWMCON0*8)+3;
volatile bit PWM2EN @ ((unsigned)&PWMCON0*8)+2;
volatile bit PWM1EN @ ((unsigned)&PWMCON0*8)+1;
volatile bit PWM0EN @ ((unsigned)&PWMCON0*8)+0;



volatile bit PWM2DTEN @ ((unsigned)&PWMCON1*8)+5;
volatile bit PWM0DTEN @ ((unsigned)&PWMCON1*8)+4;
volatile bit DT_DIV1 @ ((unsigned)&PWMCON1*8)+1;
volatile bit DT_DIV0 @ ((unsigned)&PWMCON1*8)+0;



volatile bit PWM4DIR @ ((unsigned)&PWMCON2*8)+4;
volatile bit PWM3DIR @ ((unsigned)&PWMCON2*8)+3;
volatile bit PWM2DIR @ ((unsigned)&PWMCON2*8)+2;
volatile bit PWM1DIR @ ((unsigned)&PWMCON2*8)+1;
volatile bit PWM0DIR @ ((unsigned)&PWMCON2*8)+0;



volatile bit EEDAT7 @ ((unsigned)&EEDAT*8)+7;
volatile bit EEDAT6 @ ((unsigned)&EEDAT*8)+6;
volatile bit EEDAT5 @ ((unsigned)&EEDAT*8)+5;
volatile bit EEDAT4 @ ((unsigned)&EEDAT*8)+4;
volatile bit EEDAT3 @ ((unsigned)&EEDAT*8)+3;
volatile bit EEDAT2 @ ((unsigned)&EEDAT*8)+2;
volatile bit EEDAT1 @ ((unsigned)&EEDAT*8)+1;
volatile bit EEDAT0 @ ((unsigned)&EEDAT*8)+0;



volatile bit EEADR7 @ ((unsigned)&EEADR*8)+7;
volatile bit EEADR6 @ ((unsigned)&EEADR*8)+6;
volatile bit EEADR5 @ ((unsigned)&EEADR*8)+5;
volatile bit EEADR4 @ ((unsigned)&EEADR*8)+4;
volatile bit EEADR3 @ ((unsigned)&EEADR*8)+3;
volatile bit EEADR2 @ ((unsigned)&EEADR*8)+2;
volatile bit EEADR1 @ ((unsigned)&EEADR*8)+1;
volatile bit EEADR0 @ ((unsigned)&EEADR*8)+0;



volatile bit EEDATH7 @ ((unsigned)&EEDATH*8)+7;
volatile bit EEDATH6 @ ((unsigned)&EEDATH*8)+6;
volatile bit EEDATH5 @ ((unsigned)&EEDATH*8)+5;
volatile bit EEDATH4 @ ((unsigned)&EEDATH*8)+4;
volatile bit EEDATH3 @ ((unsigned)&EEDATH*8)+3;
volatile bit EEDATH2 @ ((unsigned)&EEDATH*8)+2;
volatile bit EEDATH1 @ ((unsigned)&EEDATH*8)+1;
volatile bit EEDATH0 @ ((unsigned)&EEDATH*8)+0;



volatile bit EEADRH3 @ ((unsigned)&EEADRH*8)+3;
volatile bit EEADRH2 @ ((unsigned)&EEADRH*8)+2;
volatile bit EEADRH1 @ ((unsigned)&EEADRH*8)+1;
volatile bit EEADRH0 @ ((unsigned)&EEADRH*8)+0;



volatile bit PWMD19 @ ((unsigned)&PWMD01H*8)+5;
volatile bit PWMD18 @ ((unsigned)&PWMD01H*8)+4;
volatile bit PWMD09 @ ((unsigned)&PWMD01H*8)+1;
volatile bit PWMD08 @ ((unsigned)&PWMD01H*8)+0;



volatile bit PWMD39 @ ((unsigned)&PWMD23H*8)+5;
volatile bit PWMD38 @ ((unsigned)&PWMD23H*8)+4;
volatile bit PWMD29 @ ((unsigned)&PWMD23H*8)+1;
volatile bit PWMD28 @ ((unsigned)&PWMD23H*8)+0;



volatile bit ANS7 @ ((unsigned)&ANSEL*8)+7;
volatile bit ANS6 @ ((unsigned)&ANSEL*8)+6;
volatile bit ANS5 @ ((unsigned)&ANSEL*8)+5;
volatile bit ANS4 @ ((unsigned)&ANSEL*8)+4;
volatile bit ANS3 @ ((unsigned)&ANSEL*8)+3;
volatile bit ANS2 @ ((unsigned)&ANSEL*8)+2;
volatile bit ANS1 @ ((unsigned)&ANSEL*8)+1;



volatile bit ANS13 @ ((unsigned)&ANSELH*8)+5;
volatile bit ANS12 @ ((unsigned)&ANSELH*8)+4;
volatile bit ANS11 @ ((unsigned)&ANSELH*8)+3;
volatile bit ANS10 @ ((unsigned)&ANSELH*8)+2;
volatile bit ANS9 @ ((unsigned)&ANSELH*8)+1;
volatile bit ANS8 @ ((unsigned)&ANSELH*8)+0;



volatile bit EEPGD @ ((unsigned)&EECON1*8)+7;
volatile bit WRERR @ ((unsigned)&EECON1*8)+3;
volatile bit WREN @ ((unsigned)&EECON1*8)+2;
volatile bit WR @ ((unsigned)&EECON1*8)+1;
volatile bit RD @ ((unsigned)&EECON1*8)+0;



volatile bit WPUA7 @ ((unsigned)&WPUA*8)+7;
volatile bit WPUA6 @ ((unsigned)&WPUA*8)+6;
volatile bit WPUA5 @ ((unsigned)&WPUA*8)+5;
volatile bit WPUA4 @ ((unsigned)&WPUA*8)+4;
volatile bit WPUA3 @ ((unsigned)&WPUA*8)+3;
volatile bit WPUA2 @ ((unsigned)&WPUA*8)+2;
volatile bit WPUA1 @ ((unsigned)&WPUA*8)+1;
volatile bit WPUA0 @ ((unsigned)&WPUA*8)+0;


# 27 "C:\Program Files (x86)\SCMCU_IDE_V2.00.07\data\include\sc.h"
#pragma intrinsic(__nop)
extern void __nop(void);

# 76
extern unsigned int flash_read(unsigned short addr);


# 149
#pragma intrinsic(_delay)
extern __nonreentrant void _delay(unsigned long);

# 184
extern unsigned char __resetbits;
extern __bit __powerdown;
extern __bit __timeout;

# 19 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\base.h"
typedef unsigned char uchar;
typedef unsigned short ushort;
typedef unsigned int uint;
typedef unsigned long ulong;

typedef signed long s32;
typedef signed short s16;
typedef signed char s8;

# 32
typedef signed long const sc32;
typedef signed short const sc16;
typedef signed char const sc8;

typedef volatile signed long vs32;
typedef volatile signed short vs16;
typedef volatile signed char vs8;

# 45
typedef volatile signed long const vsc32;
typedef volatile signed short const vsc16;
typedef volatile signed char const vsc8;

typedef unsigned long u32;
typedef unsigned short u16;
typedef unsigned char u8;

# 57
typedef unsigned long const uc32;
typedef unsigned short const uc16;
typedef unsigned char const uc8;

typedef volatile unsigned long vu32;
typedef volatile unsigned short vu16;
typedef volatile unsigned char vu8;

# 69
typedef volatile unsigned long const vuc32;
typedef volatile unsigned short const vuc16;
typedef volatile unsigned char const vuc8;


typedef u8 uint8;
typedef u16 uint16;
typedef u32 uint32;
typedef s8 int8;
typedef s16 int16;
typedef s32 int32;

# 100
typedef u8 uint8_t;
typedef u16 uint16_t;
typedef u32 uint32_t;
typedef s8 int8_t;
typedef s16 int16_t;
typedef s32 int32_t;

# 123
typedef enum
{
FALSE = 0,
TRUE = !FALSE
} bool;

typedef enum
{
RESET = 0,
SET = !RESET
} FlagStatus;

typedef enum
{
DISABLE = 0,
ENABLE = !DISABLE
} FunctionalState;

typedef enum
{
ERROR = 0,
SUCCESS = !ERROR
} ErrorStatus;

# 188
typedef union
{
struct
{
u8 h1:4;
u8 h2:4;
} hex;
u8 num;
} HEX_U8;

typedef union
{
struct
{
u8 h3:4;
u8 h4:4;
u8 h1:4;
u8 h2:4;
} hex;
struct
{
u8 b2;
u8 b1;
} byte;
u8 bytes[2];
u16 num;
} HEX_U16;

typedef union
{
struct
{
u8 h7:4;
u8 h8:4;
u8 h5:4;
u8 h6:4;
u8 h3:4;
u8 h4:4;
u8 h1:4;
u8 h2:4;
} hex;
struct
{
u8 b4;
u8 b3;
u8 b2;
u8 b1;
} byte;
u8 bytes[4];
u32 num;
} HEX_U32;


typedef union
{
struct
{
u8 b0:1;
u8 b1:1;
u8 b2:1;
u8 b3:1;
u8 b4:1;
u8 b5:1;
u8 b6:1;
u8 b7:1;
} bits;
u8 allBits;
} FLAGS8;

typedef union
{
struct
{
u8 H;
u8 L;
} byte;
struct
{
u8 b8:1;
u8 b9:1;
u8 b10:1;
u8 b11:1;
u8 b12:1;
u8 b13:1;
u8 b14:1;
u8 b15:1;
u8 b0:1;
u8 b1:1;
u8 b2:1;
u8 b3:1;
u8 b4:1;
u8 b5:1;
u8 b6:1;
u8 b7:1;
} bits;
u16 allBits;
} FLAGS16;

# 4 "C:\Program Files (x86)\SCMCU_IDE_V2.00.07\data\include\__size_t.h"
typedef unsigned size_t;

# 14 "C:\Program Files (x86)\SCMCU_IDE_V2.00.07\data\include\string.h"
extern void * memcpy(void *, const void *, size_t);
extern void * memmove(void *, const void *, size_t);
extern void * memset(void *, int, size_t);

# 34
extern char * strcat(char *, const char *);
extern char * strcpy(char *, const char *);
extern char * strncat(char *, const char *, size_t);
extern char * strncpy(char *, const char *, size_t);
extern char * strdup(const char *);
extern char * strtok(char *, const char *);


extern int memcmp(const void *, const void *, size_t);
extern int strcmp(const char *, const char *);
extern int stricmp(const char *, const char *);
extern int strncmp(const char *, const char *, size_t);
extern int strnicmp(const char *, const char *, size_t);
extern void * memchr(const void *, int, size_t);
extern size_t strcspn(const char *, const char *);
extern char * strpbrk(const char *, const char *);
extern size_t strspn(const char *, const char *);
extern char * strstr(const char *, const char *);
extern char * stristr(const char *, const char *);
extern char * strerror(int);
extern size_t strlen(const char *);
extern char * strchr(const char *, int);
extern char * strichr(const char *, int);
extern char * strrchr(const char *, int);
extern char * strrichr(const char *, int);

# 72 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\global.h"
typedef enum
{
WM_Poweroff,
WM_Standby,
WM_Work ,
WM_Sleep,
WM_Charge,
} _WorkMode;

typedef enum
{
CS_ChrNull = 0,
CS_ChrPre = 1,
CS_ChrCC = 2,
CS_ChrCV = 3,
CS_ChrEnd = 4,
CS_ChrError = 5,
} ChrState;

typedef enum
{
LM_Off = 0,
LM_Red_On,
LM_white_On,
LM_white_1Hz,
LM_white_2Hz,
LM_white_1Hz_3T,
LM_Red_1HZ_3T,
LM_white_1HZ_5T,
LM_Red_1HZ_10T,
LM_Red_2HZ_10T,
LM_Redwhite_1HZ_1T,
} _LedMode;

# 23 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\var_define.h"
extern bit gbTime10ms;
extern volatile u8 gTimeCntFor10ms;

extern volatile bit gIsCupOk;
extern volatile bit gbCupEvent;
extern volatile bit gbLedWait;
extern volatile bit gbOcp;
extern volatile bit gbUcp;
extern volatile bit gbUsbPlugIn;
extern volatile bit gbUsbPlugInEvent;
extern volatile bit gbBatCharge;
extern volatile bit gIsCharging;
extern volatile bit gbitChrPwmDuty;
extern bit gbKeyClick;
extern bit gbKeyDouClick;
extern bit gbWorkLowVol;

extern _WorkMode workMode;
extern u8 gFun_workTimeCntFor1s;
extern u16 gFun_workTimeCnt;
extern u8 gFun_adcIndex;
extern u8 gFun_adcChIndex;
extern u8 gFun_adcCh;
extern u16 gFun_adcBuffer;
extern u16 gFun_adcBufferSum;
extern u16 gFun_adBatCur;
extern u16 gFun_adBatVol;
extern u16 gFun_adChrCur;
extern u16 gFun_adMidVol2;
extern u16 gFun_adMidVol3;
extern u16 gFun_chrBatCur;
extern u16 gFun_chrUsbCur;
extern u16 gFun_batCur;
extern u16 gFun_batVol;
extern u16 gFun_batMidVol;
extern u16 gFun_batMidVol2;
extern u16 gFun_batMidVol3;
extern u8 gFun_batVolState;
extern u8 gFun_motoCurrState;
extern u8 gFun_adcDealDelay;
extern u8 gFun_ocpTimeCnt;
extern u8 gFun_ucpTimeCnt;

extern u8 gFun_keyTimeCnt;
extern u8 gFun_keyIdleCnt;
extern u8 gFun_cupUsbCodeBuff;
extern u8 gFun_cupUsbCode;
extern u8 gFun_cupUsbState;
extern u8 gFun_cupUsbTimeCnt;

extern u8 gFun_ledCnt_1hz;
extern u8 gFun_ledCnt_2hz;
extern _LedMode ledMode;
extern u16 gFun_ledTimeCnt;
extern u16 gFun_ledStopCnt;
extern ChrState gBat_chrState;
extern u16 gBat_chrPwmDuty;
extern u16 gBat_chrPwmAimCur;
extern u8 gBat_chrPwmDelayCnt;
extern u8 gBat_chrPwmDelay;
extern u8 gBat_chrCvDelayCnt;

# 108 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\global.h"
extern u16 adStart5sCnt;

# 20 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\function.h"
extern bit cupIndex;


extern void FUN_Init(void);
extern void FUN_Driver(void);
extern void CUP_USB_Driver(void);
extern void KEY_Driver(void);
extern void KEY_WorkDriver(void);
extern void MCU_SleepConfig(u8 isSleep);
extern void MCU_EnterSleep(void);

extern void ADC_Deal(void);
extern void BAT_Init(void);
extern void BAT_Driver(void);

extern void LED_Display(void);
extern void Move_Function(void);

# 19 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\function_work.h"
extern u8 charPeriod;
extern bit charindex;
extern u8 pwmTarget;
extern u16 charDisplayCnt;
extern u16 sleep10sTimeCnt;

extern void Run_State(void);

# 20 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\mcu_timer.h"
extern void MCU_TimerInit(void);

# 36 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\mcu_gpio.h"
extern void MCU_GpioInit(void);
extern void MCU_GpioSetToSleep(void);

# 20 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\mcu_int.h"
extern void MCU_IntInit(void);

# 95 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\mcu_pwm.h"
extern void MCU_PwmInit(void);
extern void MCU_PWM2_SetDuty(u8 duty);

# 20 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\mcu_adc.h"
extern void MCU_AdcInit(void);
extern u16 MCU_GetAd(u8 ch);
extern void ADC_Driver(void);
extern void ADC_Sample(unsigned char adch);

# 25 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\mcu_config.h"
extern void MCU_Config(void);

# 23 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\var_define.h"
extern bit gbTime10ms;
extern volatile u8 gTimeCntFor10ms;

extern volatile bit gIsCupOk;
extern volatile bit gbCupEvent;
extern volatile bit gbLedWait;
extern volatile bit gbOcp;
extern volatile bit gbUcp;
extern volatile bit gbUsbPlugIn;
extern volatile bit gbUsbPlugInEvent;
extern volatile bit gbBatCharge;
extern volatile bit gIsCharging;
extern volatile bit gbitChrPwmDuty;
extern bit gbKeyClick;
extern bit gbKeyDouClick;
extern bit gbWorkLowVol;

extern _WorkMode workMode;
extern u8 gFun_workTimeCntFor1s;
extern u16 gFun_workTimeCnt;
extern u8 gFun_adcIndex;
extern u8 gFun_adcChIndex;
extern u8 gFun_adcCh;
extern u16 gFun_adcBuffer;
extern u16 gFun_adcBufferSum;
extern u16 gFun_adBatCur;
extern u16 gFun_adBatVol;
extern u16 gFun_adChrCur;
extern u16 gFun_adMidVol2;
extern u16 gFun_adMidVol3;
extern u16 gFun_chrBatCur;
extern u16 gFun_chrUsbCur;
extern u16 gFun_batCur;
extern u16 gFun_batVol;
extern u16 gFun_batMidVol;
extern u16 gFun_batMidVol2;
extern u16 gFun_batMidVol3;
extern u8 gFun_batVolState;
extern u8 gFun_motoCurrState;
extern u8 gFun_adcDealDelay;
extern u8 gFun_ocpTimeCnt;
extern u8 gFun_ucpTimeCnt;

extern u8 gFun_keyTimeCnt;
extern u8 gFun_keyIdleCnt;
extern u8 gFun_cupUsbCodeBuff;
extern u8 gFun_cupUsbCode;
extern u8 gFun_cupUsbState;
extern u8 gFun_cupUsbTimeCnt;

extern u8 gFun_ledCnt_1hz;
extern u8 gFun_ledCnt_2hz;
extern _LedMode ledMode;
extern u16 gFun_ledTimeCnt;
extern u16 gFun_ledStopCnt;
extern ChrState gBat_chrState;
extern u16 gBat_chrPwmDuty;
extern u16 gBat_chrPwmAimCur;
extern u8 gBat_chrPwmDelayCnt;
extern u8 gBat_chrPwmDelay;
extern u8 gBat_chrCvDelayCnt;

# 5 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\struct.h"
typedef struct
{
u8 index;
u8 chAisle;
u8 chIndex;
u16 adcBuffer;
u16 adcBufferTemp;
u8 quantity;
u16 batTotal;
u16 batV1;
u16 batV2;
u16 batILoad;
u16 batChar;
u16 batCharBank;
u8 adcpwmDuty;
u8 pwmDuty;
u16 aVolTemp;
u8 volCnt;
u16 aVolBank;
}_ADC;
extern _ADC adc;

typedef struct
{
u8 sw1Temp;
u8 sw1Index;
u8 sw2Temp;
u8 sw2Index;
u8 testmpp;
}_KEY;
extern _KEY key;

typedef struct
{
u16 sw1Cnt;
u16 sw2Cnt;
u16 stanbyCnt;
u16 work;
u16 workStopCnt;
u16 ledStopTime;
u16 ledStopCnt;
u16 low6_4v3sCnt;
}_TIMER;
extern _TIMER timer;

typedef struct
{
u8 flicker1hzCnt;
u8 flicker2hzCnt;
u8 tempBank;
}_LED;
extern _LED led;

typedef struct
{
u8 inWorkIndex;
u8 motorLock;
}_WORK;
extern _WORK work;

typedef struct
{
u8 pwmValue;
u8 pwmCycle;

}_SOFT;
extern _SOFT soft;

# 39 "F:\data\Ð¾Â“°lSCMCU\JBQ-B04L1\soft\SOFT\Source\function.c"
u16 adStart5sCnt = 0;
u16 firstSleepTimeCnt = 0;
bit firstSleepIndex = 0;

# 46
void DelayUs(u8 time)
{
while(time--)
{
__nop();
}
}

u8 keyTemp = 0;
bit keyDouble = 0;
u8 KeyTime = 0;

# 61
void KEY_Driver(void)
{

if (key.sw1Temp > 250){
key.sw1Temp = 250;
}


if ((RA3==0) && (RB5==1) && timer.ledStopCnt==0){
key.sw1Temp++;
if (key.sw1Temp == 2){
key.sw1Index = 1;
sleep10sTimeCnt = 0;
}
}else{
key.sw1Temp = 0;
key.sw1Index = 0;
}



if (key.sw2Temp > 250){
key.sw2Temp = 250;
}
if ((RB5==0) && (RA3==1) && timer.ledStopCnt==0){
key.sw2Temp++;
sleep10sTimeCnt = 0;
if (key.sw2Temp == 2){
key.sw2Index = 1;
if (workMode != WM_Standby){
ledMode = LM_Red_1HZ_3T;
}
}
}else{
key.sw2Index = 0;
}
if ((RB5==1)){
key.sw2Temp = 0;
}

}

# 107
void KEY_WorkDriver(void)
{
if (key.sw1Index == 1){
timer.sw1Cnt++;

}else{
timer.sw1Cnt = 0;

}
if (timer.sw1Cnt>300 && workMode==WM_Poweroff){
timer.stanbyCnt = 0;
work.inWorkIndex = 1;
ledMode = LM_white_On;
workMode = WM_Standby;
}


}
bit usbIndex;
bit cupIndex;

# 131
void CUP_USB_Driver(void)
{

if ((RB0==0) && 1==usbIndex){
charDisplayCnt = 100;
usbIndex = 0;
workMode = WM_Charge;
timer.ledStopTime = 0;
ledMode = LM_Red_On;
charPeriod = 0;
}else if ((RB0==1) && 0==usbIndex){
usbIndex = 1;
workMode = WM_Standby;
}else{

}


}


bit gbLed1hz = 0;
bit gbLed2hz = 0;
bit gbLedEnd = 0;

# 161
void LED_Display(void)
{

if (led.tempBank != ledMode){
gbLed1hz = 0;
gbLed2hz = 0;
timer.ledStopCnt = 0;

}
led.tempBank = ledMode;

if (ledMode == LM_Off){
timer.ledStopTime = 0;
}else if (ledMode == LM_Redwhite_1HZ_1T){
timer.ledStopTime = 100;
}else if(ledMode==LM_white_1Hz_3T || ledMode==LM_Red_1HZ_3T){
timer.ledStopTime = 300;
}else if(ledMode == LM_white_1Hz_3T){
timer.ledStopTime = 300;
}else if(ledMode == LM_Red_2HZ_10T){
timer.ledStopTime = 500;
}else if(ledMode == LM_Red_1HZ_10T){
timer.ledStopTime = 1000;
}


if (timer.ledStopTime != timer.ledStopCnt){
if (timer.ledStopTime > timer.ledStopCnt){
timer.ledStopCnt++;
}
}else{
if (timer.ledStopTime!=0 && timer.ledStopCnt!=0){
timer.ledStopTime == 0;
timer.ledStopCnt == 0;
ledMode = LM_Off;
}

}


if (++led.flicker1hzCnt > 50){
led.flicker1hzCnt = 0;
gbLed1hz =~ gbLed1hz;
}

if (++led.flicker2hzCnt > 25){
led.flicker2hzCnt = 0;
gbLed2hz =~ gbLed2hz;
}


switch(ledMode) {
case LM_Off:

RB4=1;
RA1=1;
break;
case LM_Red_On:
RB4=0;
RA1=1;
break;
case LM_white_On:
RB4=1;
RA1=0;
break;
case LM_white_1Hz:
RB4=1;
if (gbLed1hz) {
RA1=0;
} else {
RA1=1;
}
break;
case LM_white_2Hz:
RB4=1;
if (gbLed2hz) {
RA1=0;
} else {
RA1=1;
}
break;
case LM_white_1Hz_3T:
RB4=1;
if (gbLed1hz) {
RA1=0;
} else {
RA1=1;
}
break;
case LM_Red_1HZ_3T:
if (gbLed1hz){
RB4=0;
} else {
RB4=1;
}
RA1=1;
break;
case LM_white_1HZ_5T:
RB4=1;
if (gbLed2hz){
RA1=0;
} else {
RA1=1;
}
break;
case LM_Red_1HZ_10T:
if (gbLed1hz){
RB4=0;
} else {
RB4=1;
}
RA1=1;
break;
case LM_Red_2HZ_10T:
if (gbLed2hz){
RB4=0;
} else {
RB4=1;

}
RA1=1;
break;
case LM_Redwhite_1HZ_1T:
if (gbLed1hz){
RB4=0;
RA1=1;
} else {
RB4=1;
RA1=0;
}
break;
default:break;
}


}

# 305
void ADC_Deal(void)
{
if (workMode == WM_Sleep) {
gFun_ucpTimeCnt = 0;
gFun_ocpTimeCnt = 0;
} else {
if (gFun_adcDealDelay < 10) {
gFun_adcDealDelay++;
return;
} else {
gFun_adcDealDelay = 0;
}


if (gFun_batVol<550 || gFun_batMidVol2<250 || gFun_batMidVol3<250 || (gFun_batVol-gFun_batMidVol)<250) {
gFun_batVolState = 0;
} else if (gFun_batVol<600 || gFun_batMidVol2<300 || gFun_batMidVol3<300 || (gFun_batVol-gFun_batMidVol2-gFun_batMidVol3)<300) {
gFun_batVolState = 1;
} else if (gFun_batVol < 700) {
gFun_batVolState = 2;
} else {
gFun_batVolState = 3;
}

# 333
if (workMode == WM_Work) {

# 340
if (gFun_batCur < 255) {
gFun_motoCurrState = 1;
if (gFun_ocpTimeCnt)
gFun_ocpTimeCnt--;
if (gFun_ucpTimeCnt)
gFun_ucpTimeCnt--;
} else {
gFun_motoCurrState = 2;
if (gFun_ocpTimeCnt < 255)
gFun_ocpTimeCnt++;
if (gFun_ucpTimeCnt)
gFun_ucpTimeCnt--;
}
if (gFun_ocpTimeCnt >= 1) {
gbOcp = 1;
}
if (gFun_ucpTimeCnt >= 50) {
gbUcp = 1;
}
} else {
gFun_ucpTimeCnt = 0;
gFun_ocpTimeCnt = 0;
}

}
}

# 372
void BAT_Init(void)
{

}




bit isErrorNeg;

# 385
void PwmDutyDriver(void)
{
u16 currError = 0;
u8 tOut;
isErrorNeg = 0;
if (gBat_chrPwmDuty > 130){
gBat_chrPwmDuty = 130;
}
if (gFun_chrUsbCur > 1500) {
gBat_chrPwmDuty = 0;
}
if (gBat_chrPwmAimCur <= 50) {
gBat_chrPwmDuty = 0;
} else {
if (gBat_chrPwmAimCur < gFun_chrUsbCur) {
isErrorNeg = 1;
currError = gFun_chrUsbCur - gBat_chrPwmAimCur;
} else {
isErrorNeg = 0;
currError = gBat_chrPwmAimCur - gFun_chrUsbCur;
}
if (currError < 80){
__nop();
tOut = 0;
gBat_chrPwmDelay = 200;
} else {
if (currError > 900){
tOut = 3;
gBat_chrPwmDelay = 30;
} else if (currError > 800){
tOut = 2;
gBat_chrPwmDelay = 40;
} else if (currError > 650){
tOut = 1;
gBat_chrPwmDelay = 40;
} else if (currError > 500){
tOut = 1;
gBat_chrPwmDelay = 80;
} else if (currError > 350){
tOut = 1;
gBat_chrPwmDelay = 130;
} else {
tOut = 1;
gBat_chrPwmDelay = 200;
}
}

if (isErrorNeg && gBat_chrPwmDuty < tOut) {
gBat_chrPwmDuty = 0;
} else {
if (isErrorNeg) {
gBat_chrPwmDuty -= tOut;
} else {
gBat_chrPwmDuty += tOut;
}
if (gBat_chrPwmDuty > 130) {
gBat_chrPwmDuty = 130;
}
}
}
}

# 453
void BAT_Driver(void)
{

# 458
if (gbUsbPlugIn==0) {
gBat_chrState = CS_ChrNull;
gBat_chrPwmDuty = 0;
gbitChrPwmDuty = 0;
gBat_chrCvDelayCnt = 0;
gBat_chrPwmDelay = 200;
MCU_PWM2_SetDuty(0);
} else {
__nop();
switch(gBat_chrState)
{
case CS_ChrNull :
if (gFun_batVol > 845) {
gBat_chrState = CS_ChrEnd;
gBat_chrPwmAimCur = 0;
} else {
gBat_chrPwmDuty = 0;
gBat_chrState = CS_ChrPre;
}
break;
case CS_ChrPre :
gBat_chrPwmAimCur = 500;
if (gFun_batVol > 560){
gBat_chrCvDelayCnt = 0;
gBat_chrState = CS_ChrCC;
}
break;
case CS_ChrCC :
gBat_chrPwmAimCur = 1050;
if (gFun_batVol>840 || gFun_batMidVol>420 || (gFun_batVol-gFun_batMidVol)>420){
gBat_chrPwmAimCur = 1000;
gBat_chrState = CS_ChrCV;
}
break;
case CS_ChrCV :
if (++gBat_chrCvDelayCnt >= 50){
gBat_chrCvDelayCnt = 0;
if (gFun_batVol>840 || gFun_batMidVol>420 || (gFun_batVol-gFun_batMidVol)>420) {
if (gBat_chrPwmAimCur > 200) {
gBat_chrPwmAimCur -= 100;
} else {
gBat_chrState = CS_ChrEnd;
}
}
}

break;
case CS_ChrEnd :
if (gFun_batVol < 820 && gFun_batMidVol<400 && (gFun_batVol-gFun_batMidVol)<400) {
gBat_chrCvDelayCnt = 0;
gBat_chrState = CS_ChrCV;
}
break;
case CS_ChrError :
break;
}
}
if (gBat_chrState >= CS_ChrPre && gBat_chrState <= CS_ChrCV) {
gIsCharging = 1;
if (gFun_batMidVol > 425 || gFun_batVol > 425 + gFun_batMidVol) {
gBat_chrState = CS_ChrEnd;
}
} else {
gIsCharging = 0;
}
if (gbitChrPwmDuty) {
gbitChrPwmDuty = 0;
PwmDutyDriver();
}

if (gIsCharging){
if (++gBat_chrPwmDelayCnt >= gBat_chrPwmDelay) {
gBat_chrPwmDelayCnt = 0;
gbitChrPwmDuty = 1;
}
MCU_PWM2_SetDuty(gBat_chrPwmDuty);
} else {
gBat_chrPwmDelayCnt = 0;
MCU_PWM2_SetDuty(0);
}

# 552
if (gFun_adBatCur || gFun_chrBatCur || gFun_batVol || gFun_chrUsbCur || gFun_adMidVol2 || gFun_adMidVol3 || gFun_batMidVol) {
__nop();
}




}

# 566
void MCU_EnterSleep(void)
{
INTCON = 0;
OPTION_REG = 0;
ADCON0 = 0;
ADCON1 = 0;
PWMCON0 = 0;
WDTCON = 0;
PWMCON0 = 0x00;

# 580
MCU_GpioSetToSleep();

PEIE = 1;
RAIE = 1;
RBIE = 1;
GIE = 1;

PORTA;
PORTB;
RAIF = 0;
RBIF = 0;

asm("clrwdt");
asm("sleep");
asm("nop");

MCU_Config();

gFun_keyIdleCnt = 255;
GIE = 1;
}

# 607
void FUN_EnterStandby(void)
{
workMode = WM_Standby;
gFun_workTimeCnt = 0;
gbOcp = 0;
gbUcp = 0;
gbWorkLowVol = 0;
}

# 621
void FUN_EnterWorkMode(void)
{
workMode = WM_Work;
gFun_workTimeCnt = 0;
gFun_workTimeCntFor1s = 0;
if (gFun_batVol<650 || gFun_batMidVol<325 || (gFun_batVol-gFun_batMidVol)<325) {

}
}

# 642
void FUN_Init(void)
{
BAT_Init();

gFun_keyIdleCnt = 255;


}

# 656
void FUN_Driver(void)
{

# 664
if (workMode == WM_Standby) {
LED_SetMode(LM_Off);
if (gbKeyDouClick) {
if (gIsCupOk) {
if (gFun_batVol > 900 && gFun_batMidVol2>300 && gFun_batMidVol3>300 && (gFun_batVol-gFun_batMidVol2-gFun_batMidVol3)>300) {
FUN_EnterWorkMode();
} else {
LED_SetMode(LM_Red_1HZ_10T);
}
} else {
LED_SetMode(LM_Red_1HZ_3T);
}
}

if (gbCupEvent && gIsCupOk) {
gFun_ledStopCnt = 0;
LED_SetMode(LM_white_1HZ_5T);
}
if(gbCupEvent && !gIsCupOk){
gFun_ledStopCnt = 0;
LED_SetMode(LM_Red_1HZ_3T);
}

if (gBat_chrState == 0 && gbLedWait==0) {
if (++gFun_workTimeCnt > 100*10) {
gFun_workTimeCnt = 0;
MCU_EnterSleep();
} else if (++firstSleepTimeCnt>100*1 && firstSleepIndex==0){
firstSleepIndex = 1;
MCU_EnterSleep();
}
} else {
gFun_workTimeCnt = 0;
}
} else if (workMode == WM_Work) {
if (gbWorkLowVol) {
LED_SetMode(LM_white_2Hz);
} else {
LED_SetMode(LM_white_On);
}
if (gbKeyClick) {
FUN_EnterStandby();
}
if (gIsCupOk==0) {
LED_SetMode(LM_Red_1HZ_3T);
FUN_EnterStandby();
}
} else if (workMode == WM_Sleep) {
LED_SetMode(LM_Off);
} else if (workMode == WM_Charge) {
if (gIsCharging){
LED_SetMode(LM_Red_On);
} else if (gBat_chrState == CS_ChrEnd){
LED_SetMode(LM_white_On);
} else {
FUN_EnterStandby();
}
}
if (workMode != WM_Charge) {
if (gbUsbPlugIn) {
workMode = WM_Charge;
}
}

if (workMode == WM_Work) {
adStart5sCnt++;
MOTO_ON();
if (++gFun_workTimeCntFor1s >=100) {
gFun_workTimeCntFor1s = 0;
if (gFun_workTimeCnt<65535)
gFun_workTimeCnt++;
if (gFun_workTimeCnt >= 40){
FUN_EnterStandby();
}
}
if (gbOcp || gbUcp || gFun_batVolState == 0) {
if (gbOcp) {
LED_SetMode(LM_Red_2HZ_10T);
} else {
if (gFun_batVolState == 0){
LED_SetMode(LM_Red_1HZ_10T);
}
}
FUN_EnterStandby();
}

} else {
adStart5sCnt = 0;
MOTO_OFF();
}

gbLedEnd = 0;
gbCupEvent = 0;
gbKeyClick = 0;
gbKeyDouClick = 0;
}

# 768
void Move_Function(void)
{

# 780
}

